const C = "https://api.d-id.com", B = "wss://notifications.d-id.com";
function U(e) {
  if (e.type === "bearer")
    return `Bearer ${e.token}`;
  if (e.type === "basic")
    return `Basic ${btoa(`${e.username}:${e.password}`)}`;
  if (e.type === "key")
    return `Client-Key ${e.clientKey}`;
  throw new Error(`Unknown auth type: ${e}`);
}
function y(e, i = C) {
  const r = async (t, n) => {
    const a = await fetch(i + (t != null && t.startsWith("/") ? t : `/${t}`), {
      ...n,
      headers: {
        ...n == null ? void 0 : n.headers,
        Authorization: U(e),
        "Content-Type": "application/json"
      }
    });
    if (!a.ok) {
      let s = await a.text().catch(() => "Failed to fetch");
      throw new Error(s);
    }
    return a.json();
  };
  return {
    get(t, n) {
      return r(t, {
        ...n,
        method: "GET"
      });
    },
    post(t, n, a) {
      return r(t, {
        ...a,
        body: JSON.stringify(n),
        method: "POST"
      });
    },
    delete(t, n, a) {
      return r(t, {
        ...a,
        body: JSON.stringify(n),
        method: "DELETE"
      });
    },
    patch(t, n, a) {
      return r(t, {
        ...a,
        body: JSON.stringify(n),
        method: "PATCH"
      });
    }
  };
}
function J(e, i = C) {
  const r = y(e, `${i}/agents`);
  return {
    create(t, n) {
      return r.post("/", t, n);
    },
    getAgents(t, n) {
      return r.get(`/${t ? `?tag=${t}` : ""}`, n).then((a) => a ?? []);
    },
    getById(t, n) {
      return r.get(`/${t}`, n);
    },
    delete(t, n) {
      return r.delete(`/${t}`, void 0, n);
    },
    update(t, n, a) {
      return r.patch(`/${t}`, n, a);
    },
    newChat(t, n) {
      return r.post(`/${t}/chat`, void 0, n);
    },
    chat(t, n, a, s) {
      return r.post(`/${t}/chat/${n}`, a, s);
    }
  };
}
function F(e, i = C) {
  const r = y(e, `${i}/knowledge`);
  return {
    createKnowledge(t, n) {
      return r.post("/", t, n);
    },
    getKnowledgeBase(t) {
      return r.get("/", t);
    },
    getKnowledge(t, n) {
      return r.get(`/${t}`, n);
    },
    deleteKnowledge(t, n) {
      return r.delete(`/${t}`, void 0, n);
    },
    createDocument(t, n, a) {
      return r.post(`/${t}/documents`, n, a);
    },
    deleteDocument(t, n, a) {
      return r.delete(`/${t}/documents/${n}`, void 0, a);
    },
    getDocuments(t, n) {
      return r.get(`/${t}/documents`, n);
    },
    getDocument(t, n, a) {
      return r.get(`/${t}/documents/${n}`, a);
    },
    getRecords(t, n, a) {
      return r.get(`/${t}/documents/${n}/records`, a);
    },
    query(t, n, a) {
      return r.post(`/${t}/query`, {
        query: n
      }, a);
    }
  };
}
function D(e, i = C) {
  const r = y(e, `${i}/chats/ratings`);
  return {
    create(t, n) {
      return r.post("/", t, n);
    },
    getByKnowledge(t, n) {
      return r.get(`/${t}`, n).then((a) => a ?? []);
    },
    update(t, n, a) {
      return r.patch(`/${t}`, n, a);
    },
    delete(t, n) {
      return r.delete(`/${t}`, n);
    }
  };
}
const V = (e) => new Promise((i) => setTimeout(i, e));
function G(e) {
  return new Promise((i, r) => {
    const {
      callbacks: t,
      host: n,
      auth: a
    } = e, {
      onMessage: s = null,
      onOpen: u = null,
      onClose: m = null,
      onError: f = null
    } = t || {}, g = new WebSocket(`${n}?authorization=${U(a)}`);
    g.onmessage = s, g.onclose = m, g.onerror = (d) => {
      console.log(d), f == null || f(d), r(d);
    }, g.onopen = (d) => {
      u == null || u(d), i(g);
    };
  });
}
async function Q(e) {
  const {
    retries: i = 1
  } = e;
  let r = null;
  for (let t = 0; (r == null ? void 0 : r.readyState) !== WebSocket.OPEN; t++)
    try {
      r = await G(e);
    } catch (n) {
      if (t === i)
        throw n;
      await V(t * 500);
    }
  return r;
}
async function X(e, i, r) {
  const t = r ? [r] : [], n = await Q({
    auth: e,
    host: i,
    callbacks: {
      onMessage: (a) => {
        const s = JSON.parse(a.data);
        t.forEach((u) => u(s.event, s));
      }
    }
  });
  return {
    socket: n,
    terminate: () => n.close(),
    subscribeToEvents: (a) => t.push(a)
  };
}
var Y = /* @__PURE__ */ ((e) => (e.Amazon = "amazon", e.Microsoft = "microsoft", e.Afflorithmics = "afflorithmics", e.Elevenlabs = "elevenlabs", e))(Y || {}), Z = /* @__PURE__ */ ((e) => (e.Public = "public", e.Premium = "premium", e.Private = "private", e))(Z || {}), _ = /* @__PURE__ */ ((e) => (e.Start = "START", e.Stop = "STOP", e))(_ || {}), A = /* @__PURE__ */ ((e) => (e.ChatAnswer = "chat/answer", e.ChatPartial = "chat/partial", e.StreamDone = "stream/done", e.StreamStarted = "stream/started", e))(A || {}), O = /* @__PURE__ */ ((e) => (e.Unrated = "Unrated", e.Positive = "Positive", e.Negative = "Negative", e))(O || {}), j = /* @__PURE__ */ ((e) => (e.Functional = "Functional", e.TextOnly = "TextOnly", e.Maintenance = "Maintenance", e))(j || {}), K = /* @__PURE__ */ ((e) => (e.Embed = "embed", e.Query = "query", e.Partial = "partial", e.Answer = "answer", e.Complete = "done", e))(K || {}), ee = /* @__PURE__ */ ((e) => (e.KnowledgeProcessing = "knowledge/processing", e.KnowledgeIndexing = "knowledge/indexing", e.KnowledgeFailed = "knowledge/error", e.KnowledgeDone = "knowledge/done", e))(ee || {}), te = /* @__PURE__ */ ((e) => (e.Knowledge = "knowledge", e.Document = "document", e.Record = "record", e))(te || {}), ne = /* @__PURE__ */ ((e) => (e.Pdf = "pdf", e.Text = "text", e.Html = "html", e.Word = "word", e.Json = "json", e.Markdown = "markdown", e.Csv = "csv", e.Excel = "excel", e.Powerpoint = "powerpoint", e.Archive = "archive", e.Image = "image", e.Audio = "audio", e.Video = "video", e))(ne || {}), R = /* @__PURE__ */ ((e) => (e.Clip = "clip", e.Talk = "talk", e))(R || {});
function re(e) {
  return e.presenter.type === R.Clip ? {
    videoType: R.Clip,
    driver_id: e.presenter.driver_id,
    presenter_id: e.presenter.presenter_id
  } : {
    videoType: R.Talk,
    source_url: e.presenter.source_url
  };
}
function H(e, i, r, t) {
  return new Promise(async (n, a) => {
    const s = await ce(re(e), {
      ...i,
      callbacks: {
        ...i.callbacks,
        onConnectionStateChange: async (u) => {
          var m, f;
          u === "connected" ? (t || (t = await r.newChat(e.id)), n({
            chat: t,
            streamingManager: s
          })) : u === "failed" && a(new Error("Cannot create connection")), (f = (m = i.callbacks).onConnectionStateChange) == null || f.call(m, u);
        },
        // TODO remove when webscoket will return partial
        onMessage: (u, m) => {
          var f, g;
          u === A.ChatPartial && ((g = (f = i.callbacks).onChatEvents) == null || g.call(f, K.Partial, {
            content: m,
            event: K.Partial
          }));
        }
      }
    });
  });
}
async function de(e, i) {
  const r = i.baseURL || C, t = i.wsURL || B, n = new AbortController(), a = J(i.auth, r), s = D(i.auth, r), u = F(i.auth, r), m = await a.getById(e), f = await X(i.auth, t, i.callbacks.onChatEvents);
  let {
    chat: g,
    streamingManager: d
  } = await H(m, i, a);
  return {
    agent: m,
    async reconnectToChat() {
      const {
        streamingManager: c
      } = await H(m, i, a, g);
      d = c;
    },
    terminate() {
      return n.abort(), f.terminate(), d.terminate();
    },
    chatId: g.id,
    chat(c) {
      return a.chat(e, g.id, {
        sessionId: d.sessionId,
        streamId: d.streamId,
        messages: c
      }, {
        signal: n.signal
      });
    },
    rate(c, p) {
      return p ? s.update(p, c) : s.create(c);
    },
    deleteRate(c) {
      return s.delete(c);
    },
    speak(c) {
      let p;
      return c.type === "text" ? p = {
        script: {
          type: "text",
          provider: c.provider,
          input: c.input,
          ssml: c.ssml || !1
        }
      } : c.type === "audio" && (p = {
        script: {
          type: "audio",
          audio_url: c.audio_url
        }
      }), d.speak(p);
    },
    getStarterMessages() {
      var c, p;
      return (c = m.knowledge) != null && c.id ? u.getKnowledge((p = m.knowledge) == null ? void 0 : p.id).then((w) => (w == null ? void 0 : w.starter_message) || []) : Promise.resolve([]);
    }
  };
}
function ae(e, i) {
  const r = y(e, i);
  return {
    createStream(t) {
      return r.post("/clips/streams", {
        driver_id: t.driver_id,
        presenter_id: t.presenter_id,
        compatibility_mode: t.compatibility_mode
      });
    },
    startConnection(t, n, a) {
      return r.post(`/clips/streams/${t}/sdp`, {
        session_id: a,
        answer: n
      });
    },
    addIceCandidate(t, n, a) {
      return r.post(`/clips/streams/${t}/ice`, {
        session_id: a,
        ...n
      });
    },
    sendStreamRequest(t, n, a) {
      return r.post(`/clips/streams/${t}`, {
        session_id: n,
        ...a
      });
    },
    close(t, n) {
      return r.delete(`/clips/streams/${t}`, {
        session_id: n
      });
    }
  };
}
function ie(e, i) {
  const r = y(e, i);
  return {
    createStream(t, n) {
      return r.post("/talks/streams", {
        source_url: t.source_url,
        driver_url: t.driver_url,
        face: t.face,
        config: t.config
      }, n);
    },
    startConnection(t, n, a, s) {
      return r.post(`/talks/streams/${t}/sdp`, {
        session_id: a,
        answer: n
      }, s);
    },
    addIceCandidate(t, n, a, s) {
      return r.post(`/talks/streams/${t}/ice`, {
        session_id: a,
        ...n
      }, s);
    },
    sendStreamRequest(t, n, a, s) {
      return r.post(`/talks/streams/${t}`, {
        session_id: n,
        ...a
      }, s);
    },
    close(t, n, a) {
      return r.delete(`/talks/streams/${t}`, {
        session_id: n
      }, a);
    }
  };
}
function se(e, i) {
  return e.map((r, t) => t === 0 ? i ? {
    index: t,
    timestamp: r.timestamp,
    bytesReceived: r.bytesReceived - i.bytesReceived,
    packetsReceived: r.packetsReceived - i.packetsReceived,
    packetsLost: r.packetsLost - i.packetsLost,
    jitter: r.jitter,
    frameWidth: r.frameWidth,
    frameHeight: r.frameHeight,
    frameRate: r.frameRate
  } : {
    index: t,
    timestamp: r.timestamp,
    bytesReceived: r.bytesReceived,
    packetsReceived: r.packetsReceived,
    packetsLost: r.packetsLost,
    jitter: r.jitter,
    frameWidth: r.frameWidth,
    frameHeight: r.frameHeight,
    frameRate: r.frameRate
  } : {
    index: t,
    timestamp: r.timestamp,
    bytesReceived: r.bytesReceived - e[t - 1].bytesReceived,
    packetsReceived: r.packetsReceived - e[t - 1].packetsReceived,
    packetsLost: r.packetsLost - e[t - 1].packetsLost,
    jitter: r.jitter,
    frameWidth: r.frameWidth,
    frameHeight: r.frameHeight,
    frameRate: r.frameRate
  });
}
let T = !1;
const v = (e, i) => T && console.log(e, i), oe = (window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection).bind(window);
async function ce(e, {
  debug: i = !1,
  callbacks: r,
  auth: t,
  baseURL: n = C
}) {
  T = i;
  const a = {
    ...r
  }, {
    startConnection: s,
    sendStreamRequest: u,
    close: m,
    createStream: f,
    addIceCandidate: g
  } = e.videoType === R.Clip ? ae(t, n) : ie(t, n), {
    id: d,
    offer: c,
    ice_servers: p,
    session_id: w
  } = await f(e), l = new oe({
    iceServers: p
  }), b = l.createDataChannel("JanusDataChannel"), k = [];
  let $ = 0, E;
  if (!w)
    throw new Error("Could not create session_id");
  l.onicecandidate = (o) => {
    v("peerConnection.onicecandidate", o), o.candidate && o.candidate.sdpMid && o.candidate.sdpMLineIndex !== null && g(d, {
      candidate: o.candidate.candidate,
      sdpMid: o.candidate.sdpMid,
      sdpMLineIndex: o.candidate.sdpMLineIndex
    }, w);
  }, l.oniceconnectionstatechange = () => {
    var o;
    v("peerConnection.oniceconnectionstatechange => " + l.iceConnectionState), (o = a.onConnectionStateChange) == null || o.call(a, l.iceConnectionState);
  }, l.ontrack = (o) => {
    var h;
    v("peerConnection.ontrack", o), (h = a.onSrcObjectReady) == null || h.call(a, o.streams[0]);
  }, b.onmessage = (o) => {
    var h, I, x;
    if (b.readyState === "open") {
      const [M, q] = o.data.split(":");
      if (M === A.StreamStarted)
        $ = k.length, E = setInterval(() => {
          l.getStats().then((L) => {
            L.forEach((S) => {
              S.type === "inbound-rtp" && S.kind === "video" && k.push(S);
            });
          });
        }, 1e3), (h = a.onVideoStateChange) == null || h.call(a, _.Start);
      else if (M === A.StreamDone) {
        clearInterval(E);
        const P = k.slice($);
        if (P) {
          const L = $ === 0 ? void 0 : k[$ - 1], S = se(P, L);
          $ = k.length, (I = a.onVideoStateChange) == null || I.call(a, _.Stop, S.sort((N, z) => z.packetsLost - N.packetsLost).slice(0, 5));
        }
      } else
        (x = a.onMessage) == null || x.call(a, M, decodeURIComponent(q));
    }
  }, await l.setRemoteDescription(c), v("set remote description OK");
  const W = await l.createAnswer();
  return v("create answer OK"), await l.setLocalDescription(W), v("set local description OK"), await s(d, W, w), v("start connection OK"), {
    /**
     * Method to send request to server to get clip or talk depend on you payload
     * @param payload 
     */
    speak(o) {
      return u(d, w, o);
    },
    /**
     * Method to close RTC connection
     */
    async terminate() {
      var o, h;
      d && (l && (l.close(), l.oniceconnectionstatechange = null, l.onnegotiationneeded = null, l.onicecandidate = null, l.ontrack = null), await m(d, w).catch((I) => {
      }), (o = a.onConnectionStateChange) == null || o.call(a, "closed"), (h = a.onVideoStateChange) == null || h.call(a, _.Stop));
    },
    /**
     * Session identifier information, should be returned in the body of all streaming requests
     */
    sessionId: w,
    /**
     * Id of current RTC stream
     */
    streamId: d,
    /**
     * Method to add callback that will be trigered on supported events
     * @param eventName 
     * @param callback 
     */
    onCallback(o, h) {
      a[o] = h;
    }
  };
}
export {
  j as ChatMode,
  K as ChatProgress,
  ne as DocumentType,
  te as KnowledgeType,
  Y as Providers,
  O as RateState,
  X as SocketManager,
  A as StreamEvents,
  ee as Subject,
  Z as VoiceAccess,
  de as createAgentManager,
  J as createAgentsApi,
  y as createClient,
  F as createKnowledgeApi,
  D as createRatingsApi,
  ce as createStreamingManager,
  re as getAgentStreamArgs
};
